<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot 整合</title>
      <link href="/2020/01/30/SpringBoot%20%E6%95%B4%E5%90%88/"/>
      <url>/2020/01/30/SpringBoot%20%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="将要做的几件事"><a href="#将要做的几件事" class="headerlink" title="将要做的几件事"></a>将要做的几件事</h2><blockquote><p><strong>整合SpringMVC</strong></p><ol><li>修改端口（server.port=8888）</li><li>访问静态资源（classpath:META/resources | classpath:resources | classpath:static |classpath:public）</li><li>配置拦截器<ol><li>自定义拦截器：实现HandlerInterceptor接口</li><li>配置拦截器：自定义一个Java配置类（@Configuration），实现WebMvcConfigurer接口</li></ol></li></ol><p><strong>整合数据源</strong></p><ol><li>引入jdbc启动器，mysql驱动</li><li>添加配置<ol><li>spring.datasource.url</li><li>spring.datasource.username</li><li>spring.datasource.password</li></ol></li></ol><p><strong>整合Mybatis</strong></p><ol><li>引入启动器</li><li>覆盖默认配置<ol><li>mybatis.type-aliases-package=com.yang.boot.bean</li><li>mybatis.mapper-locations=<code>classpath:mybatis/mappers/**/*.xml</code></li><li>代码：定义一个接口，在接口上加入@Mapper注解</li></ol></li></ol><p><strong>整合通用Mapper</strong></p><ol><li>引入启动器</li><li>代码：接口继承<code>Mapper</code></li></ol><p><strong>整合事务</strong></p><ol><li>添加@Transactional</li></ol></blockquote><h2 id="1-整合-SpringMVC"><a href="#1-整合-SpringMVC" class="headerlink" title="1. 整合 SpringMVC"></a>1. 整合 SpringMVC</h2><h3 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h3><p><img src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/newpic/20200125204045.png" alt="img"></p><p>(0) 项目结构：</p><p><img src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/newpic/20200125232518.png" alt="img"></p><p>(1) 拦截器： <code>com.yang.demospringmvc.interceptor.MyInterceptor.java</code></p><pre><code>package com.yang.boot.demospringmvc.interceptor;import org.springframework.stereotype.Component;import org.springframework.stereotype.Controller;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Component  //注册到spring容器中public class MyInterceptor implements HandlerInterceptor {    @Override    public boolean preHandle(HttpServletRequest request,                             HttpServletResponse response,                             Object handler) throws Exception {        System.out.println(&quot;前置方法正在执行...&quot;);        // 返回值 true:放行 false:拦截        return true;    }    @Override    public void postHandle(HttpServletRequest request,                           HttpServletResponse response,                           Object handler,                           ModelAndView modelAndView) throws Exception {        System.out.println(&quot;后置方法正在执行...&quot;);    }    @Override    public void afterCompletion(HttpServletRequest request,                                HttpServletResponse response,                                Object handler,                                Exception ex) throws Exception {        System.out.println(&quot;完成方法正在执行...&quot;);    }}</code></pre><p>(2) 自定义拦截器配置类：<code>com.yang.demospringmvc.config.WebMvcCOnfiguration.java</code></p><pre><code>package com.yang.boot.demospringmvc.config;import com.yang.boot.demospringmvc.interceptor.MyInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * 1. 声明这是一个配置类 * 2. 实现 WebMvcConfigurer 接口 */@Configurationpublic class WebMvcConfiguration implements WebMvcConfigurer {    @Autowired    private MyInterceptor myInterceptor;    @Override    public void addInterceptors(InterceptorRegistry registry) {        // &quot;/*&quot;表示所有单级请求   &quot;/**&quot;表示所有多级请求        registry.addInterceptor(myInterceptor).                addPathPatterns(&quot;/**&quot;);    }}</code></pre><p>(3) 控制器：<code>com.yang.demospringmvc.controller.UserController.java</code></p><pre><code>package com.yang.boot.demospringmvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class UserController {    @RequestMapping(&quot;hello&quot;)    @ResponseBody    public String hello(){        return &quot;hello&quot;;    }}</code></pre><p>(4) 全局配置文件：<code>application.properties</code></p><pre><code># 修改服务器端口server.port=8888# 修改日志级别logging.level.org.springframework=DEBUG</code></pre><p>(5) 引导类：<code>com.yang.demospringmvc.DemoSpringmvcApplication.java</code></p><pre><code>package com.yang.boot.demospringmvc;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class DemoSpringmvcApplication {    public static void main(String[] args) {        SpringApplication.run(DemoSpringmvcApplication.class, args);    }}</code></pre><p>(6) 输出结果</p><p><img src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/newpic/20200125232107.png" alt="img"></p><h2 id="2-整合数据源-内置"><a href="#2-整合数据源-内置" class="headerlink" title="2. 整合数据源[内置]"></a>2. 整合数据源[内置]</h2><p><code>SpringBoot</code> 默认数据源为 <code>HikariCP</code>，是一个高性能的JDBC连接池，性能高。</p><p>(1) 引入依赖：<code>pom.xml</code></p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>(2) 全局配置文件：<code>application.properties</code></p><pre><code># 修改服务器端口server.port=8888# 修改日志级别logging.level.org.springframework=DEBUGspring.datasource.url=jdbc:mysql://localhost:3306/springbootspring.datasource.username=rootspring.datasource.password=123456</code></pre><h2 id="3-整合Mybatis"><a href="#3-整合Mybatis" class="headerlink" title="3. 整合Mybatis"></a>3. 整合Mybatis</h2><p><img src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/newpic/20200126110900.png" alt="img"></p><p>(1) 导入依赖：<code>pom.xml</code></p><pre><code>&lt;!-- mybatis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 通用Mapper,作者开发的 --&gt;&lt;dependency&gt;    &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>(2) 全局配置文件：<code>application.properties</code></p><pre><code># 修改服务器端口server.port=8888# 修改日志级别logging.level.org.springframework=DEBUGspring.datasource.url=jdbc:mysql://localhost:3306/springbootspring.datasource.username=rootspring.datasource.password=123456mybatis.type-aliases-package=com.yang.boot.demospringmvc.bean#mybatis-mapper-locations=clsspath:mybatis/mappers/**/*.xml</code></pre><p>(3) 实体类：<code>com.yang.boot.demospringboot.bean.User.java</code></p><pre><code>package com.yang.boot.demospringmvc.bean;import org.hibernate.validator.constraints.ISBN;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;@Table(name = &quot;tb_user&quot;)public class User {    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    private String username;    private String password;    //getter setter}</code></pre><p>(4) Mybatis 映射接口：<code>com.yang.boot.demospringboot.mapper.UserMapper.java</code></p><pre><code>package com.yang.boot.demospringmvc.mapper;import com.yang.boot.demospringmvc.bean.User;import org.apache.ibatis.annotations.Mapper;/** * 整合Mybatis：需要实现通用 Mapper 接口 */@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt; {}</code></pre><h2 id="4-整合事务"><a href="#4-整合事务" class="headerlink" title="4. 整合事务"></a>4. 整合事务</h2><p>Maven已经将<code>org.springframework:spring.tx</code>依赖导入了，因此无需再导入依赖。</p><p>业务层：<code>com.yang.boot.demospringboot.UserService.java</code></p><pre><code>package com.yang.boot.demospringmvc.service;import com.yang.boot.demospringmvc.bean.User;import com.yang.boot.demospringmvc.mapper.UserMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class UserService {    @Autowired    private UserMapper userMapper;    public User queryUserById(Long id){        return this.userMapper.selectByPrimaryKey(id);    }    @Transactional    public void deleteUserById(Long id){        this.userMapper.deleteByPrimaryKey(id);    }}</code></pre><h2 id="测试整合结果"><a href="#测试整合结果" class="headerlink" title="测试整合结果"></a>测试整合结果</h2><pre><code>package com.yang.boot.demospringmvc.controller;import com.yang.boot.demospringmvc.bean.User;import com.yang.boot.demospringmvc.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping(&quot;user&quot;)public class UserController {    @Autowired    private UserService userService;    // 通过ID查询用户    @GetMapping(&quot;{id}&quot;)    @ResponseBody    public User queryUserById(@PathVariable(&quot;id&quot;)Long id){        return this.userService.queryUserById(id);    }    @RequestMapping(&quot;hello&quot;)    @ResponseBody    public String hello(){        return &quot;hello&quot;;    }}</code></pre><p><img src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/newpic/20200126113739.png" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 入门</title>
      <link href="/2020/01/30/SpringBoot%20%E5%85%A5%E9%97%A8/"/>
      <url>/2020/01/30/SpringBoot%20%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><h2 id="第一个SprinBoot程序"><a href="#第一个SprinBoot程序" class="headerlink" title="第一个SprinBoot程序"></a>第一个SprinBoot程序</h2><p><img src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/newpic/20200126134134.png" alt="img"></p><p>引入启动器</p><pre><code>&lt;-- 所有的springboot都要继承该父工程 --&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.2.4.RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;-- web启动器 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>控制器类</p><pre><code>package com.yang.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping(&quot;demo&quot;)public class DemoController {    @RequestMapping(&quot;hello&quot;)    @ResponseBody    public String Hello(){        return &quot;hello springboot!&quot;;    }}</code></pre><p>引导类：</p><pre><code>package com.yang.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @SpringBootApplication =  *      * @EnableAutoConfiguration：启用自动配置 *      * @ComponentScan：开启注解扫描 *      * SpringBootConfiguration：作用等同于@Configuration，表示该类是一个配置类，不同的是一个工程只包含一个该注解 */@SpringBootApplicationpublic class DemoApplication {    public static void main(String[] args) {        SpringApplication.run(DemoApplication.class, args);    }}</code></pre><p>输出结果</p><p><img src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/newpic/20200126133018.png" alt="img"></p><h2 id="自定义配置类"><a href="#自定义配置类" class="headerlink" title="自定义配置类"></a>自定义配置类</h2><p>SpringBoot内部已经配置了一百多个配置类（真是贴心啊），我们可以直接使用</p><p>当我们需要其他的配置类时，我们也可以自定义一个配置类</p><p>回顾以前SSM配置数据库连接池的方式：</p><pre><code>&lt;bean name=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClassName}&quot; /&gt;     &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;&lt;/bean&gt;</code></pre><p>SpringBoot使用Java配置类，来代替xml配置：</p><blockquote><p>@Configuration：声明一个类作为配置类，代替<code>xml</code>文件</p><p>@Bean：声明在方法上，将方法的返回值加入spring容器，代替``标签</p><p>@PropertySource：指定外部属性文件</p><p>@Value：属性注入</p></blockquote><h3 id="传统配置类"><a href="#传统配置类" class="headerlink" title="传统配置类"></a>传统配置类</h3><p><img src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/newpic/20200126135650.png" alt="img"></p><p>引入启动器</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.github.drtrang&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot2-starter&lt;/artifactId&gt;    &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>jdbc配置文件</p><pre><code>jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql:///speingbootjdbc.username=rootjdbc.password=123456</code></pre><p>java配置类</p><pre><code>package com.yang.demo.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import javax.sql.DataSource;@Configuration@PropertySource(&quot;classpath:jdbc.properties&quot;)public class jdbcConfiguration {    @Value(&quot;${jdbc.driverClassName}&quot;)    private String driverClassName;    @Value(&quot;${jdbc.url}&quot;)    private String url;    @Value(&quot;${jdbc.username}&quot;)    private String username;    @Value(&quot;${jdbc.password}&quot;)    private String password;    @Bean    public DataSource dataSource(){        DruidDataSource dataSource = new DruidDataSource();        dataSource.setDriverClassName(this.driverClassName);        dataSource.setUrl(this.url);        dataSource.setUsername(this.username);        dataSource.setPassword(this.password);        return dataSource;    }}</code></pre><p>控制器</p><pre><code>package com.yang.demo.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.sql.DataSource;@Controller@RequestMapping(&quot;demo&quot;)public class DemoController {    @Autowired    private DataSource dataSource;    @RequestMapping(&quot;hello&quot;)    @ResponseBody    public String Hello(){        return &quot;hello springboot!&quot;;    }}</code></pre><h3 id="SpringBoot配置类"><a href="#SpringBoot配置类" class="headerlink" title="SpringBoot配置类"></a>SpringBoot配置类</h3><p>接下来使用SpringBoot来进行连接池配置：</p><p>思路：使用SpringBoot内置的属性配置文件，将读取属性的步骤单独抽取出来，达到复用的效果</p><p><img src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/newpic/20200126153106.png" alt="img"></p><p>属性配置文件：<code>application.properties</code></p><pre><code>jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql:///speingbootjdbc.username=rootjdbc.password=123456</code></pre><p>读取属性的类</p><pre><code>package com.yang.demo.config;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = &quot;jdbc&quot;) //读取资源配置类中，前缀为jdbc的属性public class JdbcProperties {    private String driverClassName;    private String url;    private String username;    private String password;    //getter setter}</code></pre><p>配置类</p><pre><code>package com.yang.demo.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;@Configuration@EnableConfigurationProperties(JdbcProperties.class) //启动资源配置读取类public class jdbcConfiguration {    // 方法1 @Autowired注入    @Autowired    private JdbcProperties jdbcProperties;    @Bean     public DataSource dataSource(){        DruidDataSource dataSource = new DruidDataSource();        dataSource.setDriverClassName(this.jdbcProperties.getDriverClassName());        dataSource.setUrl(this.jdbcProperties.getUrl());        dataSource.setUsername(this.jdbcProperties.getUsername());        dataSource.setPassword(this.jdbcProperties.getPassword());        return dataSource;    }}</code></pre><h3 id="属性注入的4种方法"><a href="#属性注入的4种方法" class="headerlink" title="属性注入的4种方法"></a>属性注入的4种方法</h3><p>上述配置类，使用@Autowired注入了属性，还可以采用其他方式注入：</p><pre><code>// 方法1 @Autowired注入@Autowiredprivate JdbcProperties jdbcProperties;// 方法2 构造器参数注入private JdbcProperties jdbcProperties;public jdbcConfiguration(JdbcProperties jdbcProperties){    this.jdbcProperties = jdbcProperties;}// 方法3 作为形参注入@Beanpublic DataSource dataSource(JdbcProperties jdbcProperties){    DruidDataSource dataSource = new DruidDataSource();    dataSource.setDriverClassName(jdbcProperties.getDriverClassName());    dataSource.setUrl(jdbcProperties.getUrl());    dataSource.setUsername(jdbcProperties.getUsername());    dataSource.setPassword(jdbcProperties.getPassword());    return dataSource;}// 方法4 @Bean + @ConfigurationProperties@Configurationpublic class jdbcConfiguration {    // 将jdbcProperties.java的ConfigurationProperties移动到此处    @Bean    @ConfigurationProperties(prefix = &quot;jdbc&quot;) //读取资源配置类中，前缀为jdbc的属性    public DataSource dataSource(){        DruidDataSource dataSource = new DruidDataSource();        return dataSource;    }}</code></pre><h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot thymeleaf</title>
      <link href="/2020/01/30/SpringBoot%20thymeleaf/"/>
      <url>/2020/01/30/SpringBoot%20thymeleaf/</url>
      
        <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>SpringBoot不支持jsp，但是支持一些模板引擎技术</p><p>主流的模板引擎技术：</p><blockquote><p>FreeMarker</p><p>==Thymeleaf==</p><p>Mustache</p></blockquote><p>SpringBoot 常用的模板引擎技术是<code>Thymeleaf</code></p><p><code>Thymeleaf</code>可以完全替代JSP，有以下4个特点：</p><blockquote><p>动静结合（有无网络均可运行）</p><p>开箱即用</p><p>多方言支持</p><p>与SpringBoot完美整合</p></blockquote><pre><code>Thymeleaf`默认解析位置：`src/main/resources/templates/xxx.html</code></pre><h2 id="第一个thymeleaf程序"><a href="#第一个thymeleaf程序" class="headerlink" title="第一个thymeleaf程序"></a>第一个thymeleaf程序</h2><p>以下配置是基于SpringBoot整合的基础上，若没有配置，请移步配置。</p><p>引入启动器</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>修改默认配置：</p><p>thymeleaf会在第一次对模板解析之后进行缓存，提高了并发处理能力</p><p>但是给开发带来了不便（修改页面并不会立即看到效果），因此在<code>开发阶段</code>关闭缓存。</p><pre><code># 关闭thymeleaf缓存spring.thymeleaf.cache=false</code></pre><p>DAO层接口：</p><pre><code>package com.yang.boot.demospringmvc.mapper;import com.yang.boot.demospringmvc.bean.User;import org.apache.ibatis.annotations.Mapper;/** * 整合Mybatis：需要实现通用 Mapper 接口 */@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt; {}</code></pre><p>业务层：</p><pre><code>package com.yang.boot.demospringmvc.service;import com.yang.boot.demospringmvc.bean.User;import com.yang.boot.demospringmvc.mapper.UserMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class UserService {    @Autowired    private UserMapper userMapper;    public List&lt;User&gt; queryAllUser(){        return this.userMapper.selectAll();    }}</code></pre><p>控制层：</p><pre><code>package com.yang.boot.demospringmvc.controller;import com.yang.boot.demospringmvc.bean.User;import com.yang.boot.demospringmvc.service.UserService;import org.apache.logging.log4j.message.ReusableMessage;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.util.List;@Controller@RequestMapping(&quot;user&quot;)public class UserController {    @Autowired    private UserService userService;    @GetMapping(&quot;all&quot;)    public String queryAllUser(Model model){        List&lt;User&gt; userList = this.userService.queryAllUser();        model.addAttribute(&quot;userList&quot;,userList);        return &quot;users&quot;;    }}</code></pre><p>静态文件：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;用户列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;table border=&quot;1&quot;&gt;            &lt;tr&gt;                &lt;th&gt;ID&lt;/th&gt;                &lt;th&gt;姓名&lt;/th&gt;                &lt;th&gt;密码&lt;/th&gt;            &lt;/tr&gt;            &lt;tr th:each=&quot;user:${userList}&quot;&gt;                &lt;td th:text=&quot;${user.id}&quot;&gt;1&lt;/td&gt;                &lt;td th:text=&quot;${user.username}&quot;&gt;张三&lt;/td&gt;                &lt;td th:text=&quot;${user.password}&quot;&gt;333&lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://yanghanblog.oss-cn-hangzhou.aliyuncs.com/newpic/20200126125027.png" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java内部类</title>
      <link href="/2020/01/30/java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2020/01/30/java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>成员内部类 （~成员变量）</p><p>静态成员内部类（~静态成员变量）</p><p>局部内部类（~局部变量）</p><p>匿名内部类</p><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>成员内部类，就像是类的成员一样</p><h3 id="1-成员内部类定义的位置"><a href="#1-成员内部类定义的位置" class="headerlink" title="(1) 成员内部类定义的位置"></a>(1) 成员内部类定义的位置</h3><blockquote><p>与成员变量和成员方法<strong>同级</strong></p></blockquote><h3 id="2-成员内部类访问外部类"><a href="#2-成员内部类访问外部类" class="headerlink" title="(2) 成员内部类访问外部类"></a>(2) 成员内部类访问外部类</h3><p>(2-1) 成员内部类可以无条件访问外部类的所有属性和方法（包括私有属性和私有方法）</p><blockquote><p>为什么？</p><p>因为成员内部类和成员方法同级。</p><p>成员方法 可以访问 本类中的私有属性和私有方法</p><p>成员内部类 也可以访问 外部类中的私有属性和私有方法</p></blockquote><p>(2-2) 成员内部类访问外部类的同名属性和同名方法：</p><ul><li>外部类.this.同名属性</li><li>外部类.this.同名方法</li></ul><pre><code>public class Outer {    // 成员变量    private int num = 99;    private int num2 = 55;    // 成员内部类    class Inner {        private int num2 = 66;        public void innerMethod(){            // 内部类访问外部类的私有属性（不同名）            System.out.println(num);    //99            // 内部类访问外部类的私有属性（同名）            System.out.println(num2);   //66            System.out.println(Outer.this.num2);    //55        }    }}</code></pre><h3 id="3-外部类访问成员内部类"><a href="#3-外部类访问成员内部类" class="headerlink" title="(3) 外部类访问成员内部类"></a>(3) 外部类访问成员内部类</h3><ul><li>创建内部类对象 (2种方式)：<code>外部类.内部类 inner = new 外部类().new 内部类();</code></li><li>访问内部类的成员：<code>inner.内部类属性;</code> —- <code>inner.内部类方法()</code></li></ul><pre><code>public class Test {    public static void main(String[] args)  {        // 第一种方式：创建内部类对象        Outer.Inner inner = new Outer().new Inner();  //必须通过Outter对象来创建        // 调用内部类对象的方法        inner.innerMethod();        // 第二种方式：创建内部类对象        Outer.Inner inner1 = outer.getInnerInstance();    }}class Outer {    // 成员变量    private int num = 99;    private int num2 = 55;    // 成员内部类    class Inner {        private int num2 = 66;        public void innerMethod(){            // 内部类访问外部类的私有属性（不同名）            System.out.println(num);    //99            // 内部类访问外部类的私有属性（同名）            System.out.println(num2);   //66            System.out.println(Outer.this.num2);    //55        }    }}</code></pre><h3 id="4-成员内部类的权限问题"><a href="#4-成员内部类的权限问题" class="headerlink" title="(4) 成员内部类的权限问题"></a>(4) 成员内部类的权限问题</h3><p>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。</p><p>和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。</p><p>由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p><p>如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。</p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring 关于IOC</title>
      <link href="/2018/09/07/Spring-IOC/"/>
      <url>/2018/09/07/Spring-IOC/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
